
events {
    worker_connections 1024;
}

http {
    server {
        listen 80;  # IPv4
        listen [::]:80; # IPv6
        server_name j12d103.p.ssafy.io;

        # HTTP-01 챌린지 방식
        # Certbot을 실행해서 인증서를 처음 가져올 때 사용함.
        # 1. Certbot이 Let's Encrypt 서버에 인증서 발급 요청을 보냄
        # 2. Let's Encrypt가 Certbot에 토큰, 과제(challenge)를 응답함.
        # 3. Certbot이 받은 토큰을 사용해 확인파일을 생성하고,
        #    /var/www/certbot/.well-known/acme-challenge/ 에 저장함.
        # 4. Certbot이 Let's Encrypt 서버에 확인 준비 완료됨 신호를 보냄
        # 5. Let's Encrypt가 http로 /var/www/certbot/.well-known/acme-challenge/{토큰} 에 접근하여 파일을 확인함.
        # 6. 파일이 확인되면 SSL 인증서를 발급해 응답하고, Certbot이 /etc/letsencrypt/live/{내 도메인}에 저장함.
        # 기본 유효기간인 90일이 다가오면(30일?) Certbot이 자동으로 갱신함
        # 위 과정은 80포트를 비워놔야하므로, nginx도 실행중이면 안됨.
        location /.well-known/acme-challenge/ {
            root /var/www/certbot;
        }

        # https로 영구 리다이렉트
        # / 경로로 시작하는 요청을 리다이렉트함.
        # 301은 영구, 302는 임시 리다이렉트 코드
        # 1. http로 요청을 보내면 nginx에서 301을 반환하며 https 주소로 이동하도록 지시함.
        # 2. 브라우저와 검색엔진이 리다이렉트를 캐싱함.
        # 3. 이후 접속부터는 브라우저가 301 응답을 기억하여 리다이렉트된 주소로 접속함.
        # 이 과정을 통해 검색 엔진 최적화가 이루어짐.
        location / {
            # request_uri는 클라이언트가 요청한 url에서 도메인,프로토콜을 뺀 경로로, 자동으로 들어감.
            # 예) http://aaa.com:8080/b/c/d?query=123 -> /b/c/d?query=123
            return 301 https://$server_name$request_uri;
        }
    }

    server {
        listen 443 ssl;
        server_name j12d103.p.ssafy.io;


        ssl_certificate /etc/letsencrypt/live/$server_name/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/$server_name/privkey.pem;

        location /jenkins {
            proxy_pass http://jenkins:8080/jenkins; # 도메인의 jenkins는 docker 서비스 이름임.
            proxy_http_version 1.1;
            proxy_set_header Host $host;    # 원래 요청의 헤더를 그대로 전달함.
            proxy_set_header X-Real-IP $remote_addr;    # 요청을 보낸 실제 IP를 전달함. 안넣으면 nginx에서 보낸 것으로 인식함.
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    # 요청 경로의 모든 IP를 기록함. 보안 추적에 사용.
            proxy_set_header X-Forwarded-Proto $scheme; # 원래 요청의 프로토콜(http, https)을 전달함. 현재는 위쪽에 영구 리다이렉트를 통해 들어오기 때문에 항상 https가 전달됨.
                                                        # 리버스 프록시(nginx)를 통해 요청을 받는 경우, 젠킨스는 원래 요청이 어떤 프로토콜인지 알 수 없음(nginx는 내부 통신으로 http를 사용하기 때문)
                                                        # 따라서 이 옵션을 통해 원래 요청 프로토콜을 전달하여 요청에 맞는 프로토콜로 응답하도록 함.
            
            # Jenkins 관련 추가 설정
            proxy_set_header X-Jenkins-Context "/jenkins";
            proxy_redirect http:// https://;    # 젠킨스가 받은 요청 프로토콜(http, https)에 따라 응답을 생성하는데, http 응답을 생성한 경우 자동으로 https로 변환해줌.
                                                # 사용자가 nginx에 https요청을 보내더라도, nginx → jenkins 내부 통신은 http로 이루어지기 때문에 젠킨스는 http 응답을 생성하게 됨.
                                                # X-Forwarded-Proto 헤더가 제대로 동작한다면 이 설정을 필요없음.
                                                # 하지만 이 헤더를 인식하지 못하는 플러그인의 경우 http응답을 생성할 가능성이 있어 백업 용도로 사용함.
        }
    }


}